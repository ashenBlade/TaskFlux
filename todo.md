# Что в этой ветке

Главная фича - переход на использование сегментированного лога, общий рефакторинг работы с диском.

Шаги:

- [x] `long` вместо `int` для индексов записей лога;

Теперь для терма и индекса записи лога используется `long`.
Также для записи лога был выделен отдельный тип `Lsn` - `Log Sequence Number`.
Вместо с `Term` это всего лишь удобные обертки над примитивным `long`.

- [x] Хранение индекса коммита в памяти, а не на диске;

Индекс коммита теперь хранится в памяти. В файле лога его нет.
Изначально он инициализируется в -1 (Tomb) и актуализируется в процессе работы:
либо существующий лидер передаст данные, либо в процессе старта кластера узлы договорятся между собой.

- [x] Сегментированный лог вместо единственного лога;

`Ух, ебать это было сложна.`

Крч, сейчас лог вместо одного большого состоит из нескольких небольших - сегментов.
Весь лог можно разделить на 2 части: закрытые сегменты и хвост:

- Запись можно вести только в хвост;
- Закрытые сегменты можно только читать.

Но если необходимо будет перезаписать уже закрытый сегмент (и при этом незакоммиченую область),
текущий хвост будет удален и этот сегмент станет новым хвостом.

Дополнительно, сделал несколько усовершенствований:

- ReadWrite блокировка - каждая операция (считай метод) выполняются в блокировке - чтения или записи:
    - Если блокировка записи, то только этот поток может выполнять операции
    - Если блокировка чтения, то могут несколько потоков ЧИТАТЬ
      Реализуется через `ReadWriteLock` примитив .NET
- Мягкий и жесткий предел размера сегмента - на сегмент накладываются 2 ограничения: жесткий и мягкий.
  Сегмент создается либо когда превышен мягкий и все записи закоммичены, либо когда превышен жесткий.
  В перспективе, это должно уменьшить кол-во операций создания файлов
- Предварительное выделение места под файлы - когда создается файл сегмента, то для него уже выделяется необходимое
  место на диске.
  Выделяется столько, сколько указано в мягком пределе.

- [x] Сначала реплицируем команду и только потом применяем + отдельный поток, который закоммиченные команды применяем;

Тут ничего сложного особо не было - просто поменял местами IDeltaExtractor из TResponse в TCommand.

> Замечание: захотелось переделать IConsensusModule в без Generic, т.е. только с байтами работать, но не стал, т.к.:
> 1. Сложно отслеживать и восстанавливать состояние при становлении лидером
> 2. Дополнительная сложность, когда необходимо обрабатывать запросы - нужно знать в каком состоянии находится узел.

- [ ] Поддержка Prometheus метрик + свои запилить;

Что делать:

1. Найти примеры приложения + их метрики:

- RabbitMQ
- Redis
- etcd
- Apache Kafka
- PostgreSQL

2. Посмотреть метрики для dotnet встроенные
3. Перейти на `WebApplication` (чтобы нормально регистрировать обработчики запросов и возможно MVC в будущем)
4. Определить метрики для своего приложения


- [ ] Отдельный режим работы, когда я единственный узел в кластере;
- [ ] Выравнивание в передаваемых по сети пакетах;
- [ ] Делать проверку на то, что клиент отключился во время обработки запроса (Task.Delay(TimeSpan, client.Accept()).

На след итерацию:

- PreRequestVote
- Поддержка кластера из 1 узла (сразу лидером становлюсь)
- На старте приложения делать таймаут перед запуском таймера, чтобы если были другие узлы кластера, то они успели
  подключиться
