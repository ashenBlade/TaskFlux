# Введение

В этом документе буду описывать все пояснения по реализации.
Логично, полезно разработчикам и инженерам поддержки.
Бизнесу тут делать нечего.

# Структуры данных

## Название очереди

Название очереди представляется структурой `QueueName`.
Само название должно удовлетворять бизнес-требованиям, указанным в [функциональной спецификации](func-spec.md#название-очереди)

В качестве кодировки используется `ASCII`.
Выбранные допустимые символы образуют непрерывный диапазон кодов из таблицы.
Начинается с 33 `!`, заканчивающиеся 126 `~`.

Поэтому проверка будет тривиальной - проверка диапазона байта символа

Первые 127 символов `ASCII` совпадают с первыми символами `UTF-8`, поэтому в случае правильного назваания, кодировки можно использовать взаимозаменяемо.

Так как максимальная длина названия 255 символов соответствует максимальному значению байта и каждый символ занимает 1 байт, 
то длина строки названия указывается байтом (беззнаковым).

# Узел

TaskFlux работает в кластере из нескольких узлов.
Каждый узел идентифицируется собственным Id.

Id представляется целым числом, начинающимся с 0 и линейно увеличивающимся.
Т.е. Id узлов в кластере начинаются с 0 и каждый другой узел имеет Id на 1 больший, чем предыдущий.
Например: 0, 1, 2, 3 или 0, 1.
Такая стратегия удобная в случае использования в коде.

Максимальное значение Id узла - 2147483647.
Представляется 4 байтным знаковым целым.
Этого более чем достаточно для реальных сред.

# Установление соединения

Клиент работает с кластером напрямую (на данный момент, клиентские запросы не перенаправляются на лидера).

## Установление соединение клиента и узла

Когда клиент присоединился к узлу, то между ними начинается процесс настройки соединения.
Это нужно для авторизации клиента и выставления общих настроек клиента и сервера.

Процесс установления соединения.

1. Клиент устанавливает соединение с узлом
2. Клиент посылает AuthorizationRequest пакет
3. Сервер авторизует клиента по переданным данным
4. Клиент получает AuthorizationResponse пакет с результатом авторизации
    1. Если авторизация завершилась ошибкой, то сервер закрывает соединение
    2. Дальнейшая работа прекращается
5. Клиент отправляет BootstrapRequest пакет
6. Сервер выставляет нужные настройки и проверяет корректность клиента
7. Клиент получает BootstrapResponse пакет
    1. Если проверка провалилась, то сервер закрывает соединение
    2. Дальнейшая работа прекращается

После указанного процесса, узел может обрабатывать запросы клиента.

Замечания:

- На данный момент авторизация не реализована - простой обмен предопределенными пакетами
- Сейчас на этапе первоначальной настройки реализована только проверка версии, никаких настроек нет.

## Получение метаданных кластера

Для гибкости работы, вместо ручного заполнения адресов и Id узлов, клиент может сам запросить данные о кластере для
дальнейшей работы с ним.

Чтобы получить метаданные кластера (узлы, Id лидера), клиент должен запросить их у любого узла с помощью
ClusterMetadataRequest пакета.
Список таких узлов передается на вход клиентской библиотеке при старте.
Далее это "Bootstrap" серверы.

После клиент поочередно перебирает этот список в попытке подключения и получения метаданных.

Для каждого Bootstrap узла из переданного списка выполняется следующая процедура для получения метаданных кластера:

1. Выполняется [настройка соединения](#установление-соединение-клиента-и-узла) с узлом
    1. Если соединиться с узлом не удалось из-за сети, то переходим к следующему адресу
    2. Если в процессе установления соединения возникла ошибка (ошибка авторизации или первоначальной настройки), то
       дальнейшая работа прекращается
2. Клиент отправляет ClusterMetadataRequest пакет
3. Сервер отправляет метаданные кластера в ClusterMetadataResponse пакете
4. Клиент сохраняет метаданные кластера
5. Если узел, с которым производилась коммуникация:
    1. Лидер: работа продолжается с этим узлом
    2. Не лидер: соединение с этим узлом закрывается, производится подключение к лидеру (если не был указан, то к
       случайному)

На этапе 1.2 дальнейшая работа прекращается, так как если авторизация/настройка провалилась на одном узле, то она
провалится и на остальных.

Замечание: если на момент запроса узел-лидер не был указан, то процесс повторяется для случайного узла из списка
полученных узлов (возможно даже со старым узлом, так как за это время он мог стать лидером).

Замечание: в пакете ClusterMetadataResponse может указываться Id текущего узла.
Пока не выставляю требований на его проверку, считаю, что всегда говорить будет с узлом кластера,
но в будущем можем сделать отдельный сервер, хранящий метаданные кластера, тогда это поле будет иметь специальное
значение.

Процесс инициализации считается успешным, если метаданные были получены.

## Ручная настройка

Если у нас уже имеется готовый список адресов узлов и их Id, процесс установления соединения и получения метаданных
будет лишним.
В этом случае, клиент уже должен знать список всех узлов кластера и их адресов.

## Метаданные кластера

Метаданные кластера передаются в пакете ClusterMetadataResponse.
Они включают в себя:

- Список адресов узлов кластера
- Id текущего лидера кластера
- Id ответившего узла

Список адресов передается в виде массива строк. Каждая строка может быть либо IP адресом, либо DNS записью (оба вместе с
портами).
Т.е. явного разделения между ними нет.

Замечание: предполагаю, что чаще будут использовать именно DNS записи, чем IP адреса

Id узлов аналогичны индексам в этом массиве:

| Индекс | Id | Адрес                |
|--------|----|----------------------|
| 0      | 0  | task-flux-0.ru:2602  |
| 1      | 1  | task-flux-1.aws.com  |
| 2      | 2  | server.org:5432      |
| 3      | 3  | 123.123.123.123:6666 |

Id узла лидера может быть не указан. Это может быть в случаях:

- Кластер только что был запущен и лидера не было изначально
- Узел, к которому подключились, был отрезан от остальных
- Узел с более актуальными данными поднялся и начался процесс выбора

В любом случае, рано или поздно лидер будет выбран, поэтому можно просто случайно подключаться к узлам и получать их
статус.

# Взаимодействие клиента и узла

После настройки соединения клиента и узла (описан в секции [установление соединения](#установление-соединения)),
клиент начинает взаимодействовать с узлом посылая пакеты команд и другие.

## Отправка команды на сервер

Команды посылаются пакетом CommandRequest.
Команда сериализуется в массив байтов и десериализуется на сервере.

Команду могут применять только лидеры.
Если пакет команды отправляется на другие узлы (последователь, кандидат), то они отправляют пакет NotLeader.
В нем указывается известный на тот момент Id узла лидера.

В случае выполнения команды, результат операции присылается в пакете CommandResponse.
Результат сериализуется в массив байтов.

## Ошибка на узле

Если на узле возникает ошибка во время обработки запроса, то узел посылает пакет ErrorResponse.
В нем (опционально) указано сообщение об ошибке.
После отправки этой команды, соединение между клиентом и сервером закрывается, так как этот пакет сигнализирует о
критической ошибке на сервере,
а не в логике приложения (например, пустая очередь, или неправильное название очереди).
 