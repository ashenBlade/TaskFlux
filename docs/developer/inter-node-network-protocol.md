# Описание

Это протокол, который используется для взаимодействия между узлами кластера.
Используемые типы данных описаны в секции [сетевого протокола](network-protocol.md#структуры-данных).

> Замечание: для репликации используется протокол рафт, поэтому названия команд выбраны таким образом.

# Структуры данных

Для обмена данными используются указанные структуры данных:

| Название | Базовый размер | Описание       | Визуальное расположение |
|----------|----------------|----------------|-------------------------|
| Term     | 4 байта        | Значение терма | Int32                   |

# Пакеты

> Для удобства, каждый маркер:
> 1. Обладает буквенным представлением в ASCII формате.
     Например, Byte('A') - байт со значением `65`.
> 2. Представляет заглавную букву, если запрос, и строчную, если ответ

## AppendEntriesRequest

Используется для отправки новых записей лога и Heartbeat (для поддержания в актуальном состоянии).
Если количество записей лога в поле `Entries` - 0, то это пакет Heartbeat.

Формат:

| Маркер    | Полный размер | Терм | ID отправителя | Коммит | Предшествующий терм | Предшествующий индекс | Кол-во записей | Терм записи | Данные записи | Чек-сумма |
|-----------|---------------|------|----------------|--------|---------------------|-----------------------|----------------|-------------|---------------|-----------|
| Byte('A') | Int32         | Term | UInt32         | UInt32 | Term                | UInt32                | UInt32         | Term        | Buffer        | UInt32    |

Поля `Терм записи` и `Данные записи` образуют одну логическую запись лога.
Они повторяются столько, сколько указано в поле `Кол-во записей`.

Т.е. если в `Кол-во записей`:

- 0 - дальше ничего нет (Heartbeat запрос)
- 1 - дальше `Терм записи`|`Данные записи`
- 2 - дальше `Терм записи`|`Данные записи`|`Терм записи`|`Данные записи`

Поле `Полный размер` содержит полный размер пакета. Нужен для правильной десериализации пакета.

Чек-сумма вычисляется для всех полей записей, включая терм и длину.
Т.е. чек-сумма вычисляется от всех байтов между полями `Кол-во записей` и `Чек-сумма`.

## AppendEntriesResponse

Отправляется в ответ на AppendEntriesRequest.

Формат:

| Маркер    | Терм | Успех |
|-----------|------|-------|
| Byte('a') | Term | Bool  |

Поля:

- `Терм` - терм, который был у принявшего команду узла.
- `Успех` - принял ли узел запрос.

## ConnectRequest

Отправляется одним узлом, когда тот хочет подключиться к другому узлу для коммуникации и репликации.

Формат:

| Маркер    | Id узла |
|-----------|---------|
| Byte('C') | Int32   |

## ConnectResponse

Отправляет узлом при получении им ConnectRequest пакета.
Уведомляет об успешности операции.
Если во время авторизации возникла ошибка (поле `Успех` - `false`),
то соединение разрывается.

Формат:

| Маркер    | Успех |
|-----------|-------|
| Byte('c') | Bool  |

## RequestVoteRequest

Используется, когда узел хочет отправить RequestVote запрос другому узлу.

Формат:

| Маркер    | Id узла | Терм узла | Терм последней записи | Индекс последней записи |
|-----------|---------|-----------|-----------------------|-------------------------|
| Byte('V') | Int32   | Term      | Term                  | UInt32                  |

## RequestVoteResponse

Используется для ответа на RequestVoteRequest пакет.

Формат:

| Маркер    | Терм | Успех |
|-----------|------|-------|
| Byte('v') | Term | Bool  |

## InstallSnapshotRequest

Используется, когда узел лидер хочет реплицировать состояние на узел последователь, если в логе нет нужных записей.

Формат:

| Маркер    | Терм | Id узла | Последний индекс | Последний терм |
|-----------|------|---------|------------------|----------------|
| Byte('S') | Term | Int32   | Int32            | Term           |

## InstallSnapshotChunkRequest

Используется для отправки файла снапшота, после отправки `InstallSnapshotRequest` пакета.

Формат:

| Маркер    | Чанк   | Чек-сумма |
|-----------|--------|-----------|
| Byte('B') | Buffer | UInt32    |

Если размер буфера в поле `Чанк` равен 0, то это означает конец передачи файла (для него также вычисляется чек-сумма).

Чек-сумма вычисляется для поля `Чанк`, включая длину.

## InstallSnapshotChunkResponse

Отправляется принимающим узлом в ответ на каждый успешно установленный чанк снапшота.

Формат:

| Маркер    |
|-----------|
| Byte('b') |

## InstallSnapshotResponse

Используется для ответа на InstallSnapshotRequest и InstallSnapshotChunk.
Отправляется каждый раз после получения каждого чанка данных из InstallSnapshotRequest.
Нужен для уведомления о готовности принимать следующий чанк и, при необходимости, известить об изменении терма (только
больший может быть).

Формат:

| Маркер    | Терм |
|-----------|------|
| Byte('s') | Term |

## RetransmitRequest

Получившая сторона отправляет этот пакет, в случае если полученный пакет нарушил целостность.
Например, переданная чек-сумма и рассчитанная не равны.
Когда кто-то получает этот пакет, то он должен повторить отправку предварительно отправленного пакета.

| Маркер    |
|-----------|
| Byte('R') |

# Чек сумма

Чек сумма используется для проверки целостности данных в принимаемом пакете.
Т.е. чек-сумма вычисляется только там, где присутствуют секции с пользовательскими данными.
Например, [`AppendEntriesRequest`](#appendentriesrequest) или [`InstallSnapshotChunkRequest`](#installsnapshotchunk).

Для создания используется алгоритм CRC32:

- Начальное значение: 0xFFFFFFFF
- Полином: 0x04C11DB7
- Зеркалированный: Нет
- XorOut: 0x0

Замечание: параметры алгоритма такие же как у CRC32/MPEG2

# Основы (база)

Взаимодействие между узлами происходит по собственному сетевому протоколу.
Протокол работает поверх TCP.

Взаимодействие ведется по принципу Клиент-Сервер.
Одна сторона посылает сообщения, а другая на них отвечает.

В каждом соединении инициатором может быть только тот, кто это соединение и установил.
Для двустороннего взаимодействия необходимо установить 2 соединения: каждая сторона устанавливает свое.
Это необходимо для исключения гонок при сетевом взаимодействии.
Например, узел перешел в состояние Кандидата и начал слать всем RequestVoteRequest пакеты, и в это же время отправляет
AppendEntriesResponse пакет - на этом моменте может возникнуть ошибка одновременного доступа к сокету.

# Взаимодействие узлов

## Установление соединения

Установление соединения инициализирует клиент.

Алгоритм установления соединения (клиент):

```mermaid
flowchart
  setup-tcp([Установить TCP соединение])
  is-tcp-connection-setup{Соединение установлено?}
  connection-not-setup([Соединение установить не удалось])
  send-connect-request-packet[Отправить ConnectRequestPacket со своим Id]
  receive-connect-response-packet[Получить ConnectResponsePacket]
  is-connect-response-success{Соединение установлено успешно?}
  connection-setup([Соединение установлено])
  setup-tcp ---> is-tcp-connection-setup
  is-tcp-connection-setup -- Нет --> connection-not-setup
  is-tcp-connection-setup -- Да --> send-connect-request-packet ---> receive-connect-response-packet ---> is-connect-response-success
  is-connect-response-success -- Нет --> connection-not-setup
  is-connect-response-success -- Да --> connection-setup
```

Алгоритм установления соединения (сервер):

```mermaid
flowchart
  accept-connection([Принять TCP соединение])
  receive-connect-request-packet[Получить ConnectRequestPacket]
  is-id-correct{Переданный Id корректный?}
  send-unsuccessful-connect-response[Отправить ConnectResponsePacket с указанием ошибки]
  close-current-connection([Закрыть текущее соединение])
  connection-exists{Есть существующее соединение с таким узлом?}
  close-old-connection[Закрыть существующее соединение]
  send-successful-connect-response[Отправить успешный ConnectResponsePacket]
  start-client-processing([Начать обрабатывать клиента])
  accept-connection ---> receive-connect-request-packet ---> is-id-correct
  is-id-correct -- Нет --> send-unsuccessful-connect-response ---> close-current-connection
  is-id-correct -- Да --> connection-exists
  connection-exists -- Да --> close-old-connection --> send-successful-connect-response
  connection-exists -- Нет --> send-successful-connect-response
  send-successful-connect-response ---> start-client-processing
```

Замечания:

- На моменте проверки переданного в ConnectRequestPacket Id узла могут возникнуть следующие ошибки:
  - Переданный Id выходит за границы валидных значений (например, отрицательный);
  - Переданный Id указывает на Id текущего узла, т.е. того кто обрабатывает запрос;
  - Переданный Id находится не в диапазоне кластера (например, в кластере 3 узла, но переданный Id - 4);
- Может случиться так, что в узле уже существует открытое соединение с другим узлом с таким же Id.
  Это может случиться в случае, если старый узел аварийно остановился (TCP соединение открыто),
  и этот узел заново запустился и устанавливает новое соединение.
  В таких ситуациях, старое соединение закрывается (принудительно) и оно замещается новым.
- Переотправка сообщений в ответ на `RetransmitRequest` пакет не поддерживается.
  Соединение либо явно установлено, либо нет.

## Синхронизация лога

Основной смысл протокола - синхронизация лога.
В этом логе содержатся сериализованные команды, которые изменяют состояние приложения.

Для синхронизации есть 2 пакета (команды): AppendEntries и InstallSnapshot.
Обе команды управляют 2 потоками работы: синхронизация основного лога команд и отправка готового снапшота,
соответственно.

Протокол основан на алгоритме консенсуса Raft.
Я мало, что там изменил (включая названия полей), поэтому за пояснениями работы отправляю
к [самому протоколу](https://raft.github.io/raft.pdf).

## Проверка согласованности

В качестве дополнительной проверки целостности используются чек-суммы.

Они используются только для проверки пользовательских данных (записи лога либо чанки снапшота).
Т.е. в пакетах [`AppendEntriesRequest`](#appendentriesrequest)
или [`InstallSnapshotChunkRequest`](#installsnapshotchunk).

В качестве чек-суммы используется алгоритм CRC32:

- Начальное значение: `0xFFFFFFFF`
- Полином: `0x04C11DB7`
- Зеркалированный: `Нет`
- XorOut: `0x0`

Замечание: параметры алгоритма такие же как у CRC32/MPEG2

При получении пакета с чек-суммой получатель должен проверить соответствие.
Если целостность была нарушена, то получающая сторона отправляет `RetransmitRequest` пакет.
Тогда отправляющая сторона должна повторить отправку сообщения.
Повторная отправка может выполняться несколько раз - ограничений не накладывается.

Данное поведение закладывается во все алгоритмы отправки пакетов и не прописывается явно, иначе слишком много текста
получится.
Если данное поведение нежелательно (как, например, при установлении соединения), то такое явно прописывается.