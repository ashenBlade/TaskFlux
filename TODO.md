# Лист работ

Что хочу сделать?

## Баг с подключением узлов

Описание: при подключении узлов сейчас есть вероятность отправки ConnectResponse вместо AppendEntries или другое

Проблема решена так:

- Код логики tcp адаптера (реального) отрефакторил, там теперь немного чище
- Скорее всего проблема была из-за состояния гонки, поэтому просто сделал декоратор с `lock` - это ок, т.к. все вызовы
  синхронные
- Чтобы более гранулярно отслеживать токен отмены - в ожидании при потере соединения регистрирую cb на отмену токена где
  вызываю `Thread.Interrupt`

Еще:

- Отслеживать токен жизни состояния - прекращать отправку, если токен был отменен

## ID для записей

Описание: каждой записи назначать собственный ID для упрощения работы

Дополнительно:

- Можно использовать `ulong`
- Учитывать при восстановлении, вставке/удалении
- Скорее всего эту логику передать в объект очереди (хранит там что-то типа счетчика, а может и Guid рандомный)

## Блокирующее чтение

Самое важное (мечта)

Описание: необходимо иметь функциональность блокирующих чтений - с таймаутом (вместо активного опроса)

Замечание: сигналировать о новой записи прямо при вставке - ок, т.к. это означает, что лидер уже работал и скорее всего
будет работать дальше.
Если перестанем быть лидером за это время, то просто скажем - сорян братан, уже не лидер.

### Обновление Dequeue логики:

1. Простой Dequeue

### TODO: переделать логику - репликация результата, а не команды

Шаги реализации:

1. Выделить место где отслеживать этих консьюмеров
2. Понять когда блокирующий, а когда нет запрос
3. Какие изменения внутри протокола
4. Что делать, если клиент отключился в момент ожидания (как убрать регистрацию)
5. Когда уведомлять о том, что вставка произошла? - когда реплицировали или в момент вставки?
6. Что делать, если перестали быть лидером, но остались консьюмеры
